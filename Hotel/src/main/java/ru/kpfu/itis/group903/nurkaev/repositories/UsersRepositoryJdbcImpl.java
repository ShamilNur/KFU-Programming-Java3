package ru.kpfu.itis.group903.nurkaev.repositories;

import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import ru.kpfu.itis.group903.nurkaev.exceptions.DuplicateEntryException;
import ru.kpfu.itis.group903.nurkaev.exceptions.WrongEmailOrPasswordException;
import ru.kpfu.itis.group903.nurkaev.forms.LoginForm;
import ru.kpfu.itis.group903.nurkaev.forms.UserForm;
import ru.kpfu.itis.group903.nurkaev.models.User;

import javax.sql.DataSource;
import java.sql.*;
import java.util.List;
import java.util.Optional;

import static ru.kpfu.itis.group903.nurkaev.queries.UserQueries.*;

/**
 * @author Shamil Nurkaev @nshamil
 * 11-903
 * Homework
 */

public class UsersRepositoryJdbcImpl implements UsersRepository {

    private final DataSource dataSource;
    private final SimpleJdbcTemplate template;
    private final PasswordEncoder encoder;

    private final RowMapper<User> userRowMapper = row -> User.builder()
            .id(row.getLong("id"))
            .firstName(row.getString("first_name"))
            .lastName(row.getString("last_name"))
            .email(row.getString("email"))
            .hashPassword(row.getString("hash_password"))
            .uuid(row.getString("uuid"))
            .build();

    public UsersRepositoryJdbcImpl(DataSource dataSource) {
        this.dataSource = dataSource;
        this.template = new SimpleJdbcTemplate(dataSource);
        this.encoder = new BCryptPasswordEncoder();
    }

    @Override
    public Optional<User> findOneByEmail(String email) {
        // this query will return list with only one user.
        // findAny returns this user.
        return template.queryForList(SQL_SELECT_BY_EMAIL, userRowMapper, email).stream().findAny();
    }

    @Override
    public void signUp(UserForm userForm) throws DuplicateEntryException {
        Optional<User> userOptional = findOneByEmail(userForm.getEmail());
        // если пользователь не найден в базе, разрешаем регистрацию
        if (!userOptional.isPresent()) {
            User user = User.builder()
                    .firstName(userForm.getFirstName())
                    .lastName(userForm.getLastName())
                    .email(userForm.getEmail())
                    .hashPassword(encoder.encode(userForm.getPassword()))
                    .uuid(userForm.getUuid())
                    .build();
            save(user);
        } else throw new DuplicateEntryException();
    }

    @Override
    public void signIn(LoginForm loginForm) throws WrongEmailOrPasswordException {
        Optional<User> userOptional = findOneByEmail(loginForm.getEmail());
        if (userOptional.isPresent()) {
            User user = userOptional.get();
            if (!encoder.matches(loginForm.getPassword(), user.getHashPassword())) {
                throw new WrongEmailOrPasswordException();
            }
        } else throw new WrongEmailOrPasswordException();
    }

    @Override
    public void save(User entity) {
        try (Connection connection = dataSource.getConnection();
             PreparedStatement preparedStatement = connection.prepareStatement(SQL_INSERT, Statement.RETURN_GENERATED_KEYS)) {

            int i = 1;
            preparedStatement.setString(i++, entity.getFirstName());
            preparedStatement.setString(i++, entity.getLastName());
            preparedStatement.setString(i++, entity.getEmail());
            preparedStatement.setString(i++, entity.getHashPassword());
            preparedStatement.setString(i, entity.getUuid());

            preparedStatement.executeUpdate();

            // setting the ID value generated by the database
            try (ResultSet resultSet = preparedStatement.getGeneratedKeys()) {
                resultSet.next();
                Long id = resultSet.getLong(1);
                entity.setId(id);
            }
        } catch (SQLException e) {
            throw new IllegalStateException(e);
        }
    }

    @Override
    public void update(User entity) {
        template.query(SQL_UPDATE_BY_ID, userRowMapper,
                entity.getFirstName(), entity.getLastName(),
                entity.getEmail(), entity.getHashPassword(), entity.getUuid());
    }

    @Override
    public void delete(User entity) {
        template.query(SQL_DELETE_BY_ID, userRowMapper, entity.getId());
    }

    @Override
    public Optional<User> findById(Long id) {
        // this query will return list with only one user.
        // findAny returns this user.
        return template.queryForList(SQL_SELECT_BY_ID, userRowMapper, id).stream().findAny();
    }

    @Override
    public List<User> findAll() {
        return template.queryForList(SQL_SELECT, userRowMapper);
    }

}
